package org.usfirst.frc4904.robot;

import com.pathplanner.lib.auto.AutoBuilder;
import com.pathplanner.lib.config.PIDConstants;
import com.pathplanner.lib.config.RobotConfig;
import com.pathplanner.lib.controllers.PPHolonomicDriveController;
import com.pathplanner.lib.path.PathPlannerPath;
import com.pathplanner.lib.trajectory.PathPlannerTrajectory;
import edu.wpi.first.math.geometry.Pose2d;
import edu.wpi.first.math.geometry.Translation2d;
import edu.wpi.first.wpilibj.DriverStation;
import edu.wpi.first.wpilibj.Timer;
import edu.wpi.first.wpilibj.smartdashboard.FieldObject2d;
import edu.wpi.first.wpilibj.smartdashboard.SendableChooser;
import edu.wpi.first.wpilibj2.command.Command;
import edu.wpi.first.wpilibj2.command.SequentialCommandGroup;
import edu.wpi.first.wpilibj2.command.WaitCommand;
import org.json.simple.parser.ParseException;
import org.usfirst.frc4904.robot.RobotMap.Component;
import org.usfirst.frc4904.robot.RobotMap.Dashboard;
import org.usfirst.frc4904.robot.swerve.SwerveSubsystem;
import org.usfirst.frc4904.standard.commands.NoOp;
import org.usfirst.frc4904.standard.util.Util;

import java.io.IOException;
import java.util.NoSuchElementException;

public final class Auton {

    // apparently cannot be higher than 85 (????) - see javadoc for FieldObject2d.setPoses()
    private static final int PATHPLANNER_PREVIEW_STEPS = 50;

    private static final double PATHPLANNER_SLOWDOWN_FACTOR = 1.5;

    private Auton() {}

    private static final FieldObject2d liveTraj = Dashboard.liveField.getObject("auton_traj");
    private static final FieldObject2d liveTarget = Dashboard.liveField.getObject("auton_next");

    /**
     * Move straight out of the starting zone and do nothing.
     */
    // public static Command c_straight() {
    //     return Component.chassis.getAutonomousCommand("straight", true, false);
    // }

   // actually moves backwards - robot must be placed physically backwards on the field
    public static Command c_jankStraight() {
        return new SequentialCommandGroup(
            new WaitCommand(12),
            Component.chassis.c_driveRobotRelative(-0.5, 0, 0).withTimeout(2),
            Component.chassis.c_stop()
        );
    }

    // actually moves forwards
    public static Command c_jankReverse() {
        return new SequentialCommandGroup(
            new WaitCommand(12),
            Component.chassis.c_driveRobotRelative(0.5, 0, 0).withTimeout(2),
            Component.chassis.c_stop()
        );
    }

    /// PATHPLANNER

    static RobotConfig pathPlannerConfig;
    static {
        try {
            pathPlannerConfig = RobotConfig.fromGUISettings();
        } catch (IOException | ParseException e) {
            System.err.println("Failed to load PathPlanner config:\n" + e.getMessage());
        }
    }

    public static void initPathplanner(SendableChooser<? super Command> autonChooser, String... names) {
        SwerveSubsystem swerve = Component.chassis;

        if (pathPlannerConfig == null) return;

        AutoBuilder.configure(
            swerve::getPoseEstimate,
            swerve::resetPose,
            swerve::getChassisSpeeds,
            (speeds, feedforwards) -> swerve.driveRobotRelative(speeds),
            new PPHolonomicDriveController(
                new PIDConstants(5, 0, 0),
                new PIDConstants(5, 0, 0)
            ),
            pathPlannerConfig,
            () -> {
                // Boolean supplier that controls when the path will be mirrored for the red alliance
                // This will flip the path being followed to the red side of the field.
                // THE ORIGIN WILL REMAIN ON THE BLUE SIDE

                var alliance = DriverStation.getAlliance();
                return alliance.isPresent() && alliance.get() == DriverStation.Alliance.Red;
            },
            swerve
        );

        for (var name : names) {
            autonChooser.addOption(name, c_pathPlanner(name));
            // autonChooser.addOption(name, new PathPlannerAuto(name));
        }
    }

    public static Command c_pathPlanner(String file) {
        try {
            PathPlannerPath path = PathPlannerPath.fromPathFile(file);
            PathPlannerTrajectory traj = path.getIdealTrajectory(pathPlannerConfig).orElseThrow();
            return new PathPlannerCommand(traj);
        } catch (IOException | ParseException e) {
            System.err.println("Failed to load PathPlanner path '" + file + "':\n" + e.getMessage());
        } catch (NoSuchElementException e) {
            System.err.println("Failed to load PathPlanner path '" + file + "'. Paths must have an ideal starting state.");
        }

        return new NoOp();
    }

    public static class PathPlannerCommand extends Command {

        public final PathPlannerTrajectory traj;
        public final double duration;

        private Pose2d[] trajPreview; // cache
        public Pose2d[] getTrajPreview() {
            if (trajPreview != null) return trajPreview;
            return trajPreview = makeTrajPreview(traj, Translation2d.kZero);
        }


        private double startTime;
        private Translation2d offset;
        private boolean atEnd;

        private final Command gotoPoseCommand;

        private PathPlannerCommand(PathPlannerTrajectory traj) {
            this.traj = traj;
            duration = traj.getTotalTimeSeconds();

            addRequirements(Component.chassis);

            // effectively a WrapperCommand of this c_gotoPose() command
            // ...BUT WrapperCommand requires that the command is provided in the super() call,
            // which can't reference class fields like `startTime` or `offset`.
            // so i'll wrap it myself i guess.
            gotoPoseCommand = Component.chassis.c_gotoPose(() -> {
                double time = (Timer.getFPGATimestamp() - startTime) / PATHPLANNER_SLOWDOWN_FACTOR;
                if (time >= duration) {
                    if (atEnd) return null;
                    else atEnd = true;
                }

                Pose2d target = sampleTraj(traj, time, offset);
                liveTarget.setPose(target);
                return target;
            });
        }

        @Override
        public void initialize() {
            startTime = Timer.getFPGATimestamp();
            Pose2d current = Component.chassis.getPoseEstimate(), initial = traj.getInitialPose();
            offset = current.getTranslation().minus(initial.getTranslation());
            atEnd = false;

            Pose2d[] poses = makeTrajPreview(traj, offset);
            liveTraj.setPoses(poses);

            gotoPoseCommand.initialize();
        }

        @Override
        public void execute() {
            gotoPoseCommand.execute();
        }

        @Override
        public void end(boolean interrupted) {
            Util.clearPose(liveTraj, liveTarget);

            gotoPoseCommand.end(interrupted);
        }

        @Override
        public boolean isFinished() {
            return gotoPoseCommand.isFinished();
        }
    }

    private static Pose2d[] makeTrajPreview(PathPlannerTrajectory traj, Translation2d offset) {
        double dur = traj.getTotalTimeSeconds();
        int steps = Math.min(PATHPLANNER_PREVIEW_STEPS, (int) Math.round(dur * 10));
        double timePerStep = dur / steps;

        Pose2d[] poses = new Pose2d[steps];
        for (int step = 0; step < steps; step++) {
            poses[step] = sampleTraj(traj, step * timePerStep, offset);
        }
        return poses;
    }

    private static Pose2d sampleTraj(PathPlannerTrajectory traj, double time, Translation2d offset) {
        Pose2d idealPose = traj.sample(time).pose;
        return new Pose2d(idealPose.getX() + offset.getX(), idealPose.getY() + offset.getY(), idealPose.getRotation());
    }
}
